function HighChartsWrapper (params){
	//console.log("In HighChartsWrapper()");
	this.params = params;
	//console.log ("Parameters passed to HighChartsWrapper");
	//console.log (this.params);
	/**
	 *
	 * translates data from XPresso to HighCharts format
	 *
	 */
	this.setJSONData = function (data, name, properties){
		
		//console.log("in HighChartsWrapper().setJSONData");
		//console.log("data="+name,data);
		console.log("properties="+JSON.stringify(properties));
		var current_theme = sessionStorage.getItem('current_theme') || 'theme_3';
		var theme_list = JSON.parse(sessionStorage.getItem('themes')) || {};
		var $chart = this.params.chart;
		if (this.chart)
			this.chart.destroy();
		if (this.params.chart.type == "area")
			this.params.plotOptions.area.fillColor.stops[0][1]=Highcharts.getOptions().colors[0];
		//console.log("params="+this.params);
		switch(this.params.chart.type)
		{
			case 'stack':
			case 'scatter':
			case 'bubble':Highcharts.setOptions({
					colors: theme_list[current_theme][$chart.type] || ['#df4b00','#6a6a6a','#ff6c00','#8a8a8a', '#ff9640',  '#aaaaaa', '#f9b576',  '#cacaca'],
					plotOptions: {
						series: {
				                states: {
				                    select: {
				                        color: theme_list[current_theme].active_item || '#1bc6bc'
				                    }
				                }
						}
					 }
			    });
				break;
			case undefined:
			case 'column':Highcharts.setOptions({
				colors: theme_list[current_theme][$chart.type] || ['#df4b00','#6a6a6a','#ff6c00','#8a8a8a', '#ff9640',  '#aaaaaa', '#f9b576',  '#cacaca'],
				plotOptions: {
					 series: {
			                states: {
			                    select: {
			                    	color: theme_list[current_theme].active_item || '#1bc6bc'
			                    }
			                }
					 }
				 }
		    });
				break;
	
			case 'bar':Highcharts.setOptions({
				colors: theme_list[current_theme][$chart.type] || ['#df4b00','#6a6a6a','#ff6c00','#8a8a8a', '#ff9640',  '#aaaaaa', '#f9b576',  '#cacaca'],
				plotOptions: {
					 series: {
			                states: {
			                    select: {
			                    	color: theme_list[current_theme].active_item || '#1bc6bc'
			                    }
			                }
					 }
				 }
		    });
				break;
			case 'pie':
			case 'heatmap':Highcharts.setOptions({
				colors: theme_list[current_theme][$chart.type] || ['#df4b00','#6a6a6a','#ff6c00','#8a8a8a', '#ff9640',  '#aaaaaa', '#f9b576',  '#cacaca'],
				plotOptions: {
					 series: {
			                states: {
			                    select: {
			                    	color: theme_list[current_theme].active_item || '#1bc6bc'
			                    }
			                }
					 }
				 }
		    });
				break;
			
		}
		
		this.chart = new Highcharts.Chart (this.params);
		this.results = data;
		this.chart.parent = this;
		if (properties.labelFormatFunction != null)
			this.chart.xAxis[0].labelFormatter = function(){return window[properties.labelFormatFunction](this)};
		var aColumnNames = data.column_names;
		
		var rows = data.rows;
		var xaxisname = (properties.xaxisname == null)?aColumnNames[0]:properties.xaxisname;
		//console.log("xaxisname="+xaxisname);
		this.chart.xAxis[0].setTitle ({
            text: xaxisname
        },true);
		
		var yaxisname = (properties.yaxisname == null)?"":properties.yaxisname;
		this.chart.yAxis[0].setTitle (yaxisname);
		
		//this.chart.setTitle ({text:name});
		var i, j, cols;
		
		if (this.params.chart.type != "bubble"){
			// set categories - contents of col 1
			var categories = "[";
			for (i = 0; i < rows.length; i ++){
				categories += "\"" + rows[i][0] + "\"";
				if (i < rows.length - 1)
					categories += ", ";
			}
			categories += "]";
			this.chart.xAxis[0].categories = new Array();
			this.chart.xAxis[0].setCategories (JSON.parse (categories), false);
		}
		//console.log("xAxis.categories="+categories);
		//this.chart.xAxis[0].setCategories (['One', 'Two', 'Three'], true);

		// set series
		this.chart.series = new Array();
		var series, oldseriesName, newSeriesName;
		if (this.params.chart.type == "scatter"){
			// special handling for scatter plot
			// expect 3 cols - col 0 is series name, cols 1 and 2 are data
			oldSeriesName = '';
			series = "{\"name\":\"" + rows[0][0] + "\",  \"data\": [";
			j = 0;
			while (j < rows.length){
				newSeriesName = rows[j][0];
				if ((newSeriesName != oldSeriesName) && (j>0)){
					// complete old series and add
					series += "]}";
					console.log("series="+series);
					this.chart.addSeries (JSON.parse (series), false);
					oldSeriesName = newSeriesName;
					series = "{\"name\":\"" + rows[j][0] + "\",  \"data\": [";
					//series += "[" + rows[j][1] + "," + rows[j][2] + "]";
					for(i=1;i<aColumnNames.length;i++)
					{
						series += "[" + rows[j][i++] + "," + rows[j][i] + "]";
						if(i==aColumnNames.length-1||rows[j][i+1]==null||rows[j][i+1]==undefined)
							{
							//console.log("null"+i);
							
							break;
							}
							
							
						else
							series+=",";
					}
				}
				else{
					// continue same series
					oldSeriesName = newSeriesName;
					if (j > 0)
						series += ",";
					for(i=1;i<aColumnNames.length;i++)
						{
						series += "[" + rows[j][i++] + "," + rows[j][i] + "]";
						if(i==aColumnNames.length-1||rows[j][i+1]==null||rows[j][i+1]==undefined)
							{
							//console.log("null"+i);
							
							break;
							}
							
							
						else
							series+=",";
						}
					
					////console.log("series="+series);
				}
				j ++;
			}
			// add last series
			series += "]}";
			//console.log("series:"+ series);
			this.chart.addSeries (JSON.parse (series), false);
			this.chart.xAxis[0].setTitle ({
	            text: aColumnNames[1]
	        },true);
			this.chart.yAxis[0].setTitle ({
	            text: aColumnNames[2]
	        },true);
		}
		else if (this.params.chart.type == "bubble"){
			// special handling for bubble plot
			// expect 4 cols - col 0 is series name, cols 1, 2 and 3 are data
			oldSeriesName = '';
			series = "{\"name\":\"" + rows[0][0] + "\",  \"data\": [";
			j = 0;
			while (j < rows.length){
				newSeriesName = rows[j][0];
				if ((newSeriesName != oldSeriesName) && (j>0)){
					// complete old series and add
					series += "]}";
					console.log("series="+series);
					this.chart.addSeries (JSON.parse (series), false);
					oldSeriesName = newSeriesName;
					series = "{\"name\":\"" + rows[j][0] + "\",  \"data\": [";
					series += "[" + rows[j][1] + "," + rows[j][2] + ", " + rows[j][3] + "]";
				}
				else{
					// continue same series
					oldSeriesName = newSeriesName;
					if (j > 0)
						series += ",";
					series += "[" + rows[j][1] + "," + rows[j][2] + ", " + rows[j][3] + "]";
					
					////console.log("series="+series);
				}
				j ++;
			}
			// add last series
			series += "]}";
			console.log("series:"+ series);
			this.chart.addSeries (JSON.parse (series), false);
			this.chart.xAxis[0].setTitle ({
	            text: aColumnNames[1]
	        },true);
			this.chart.yAxis[0].setTitle ({
	            text: aColumnNames[2]
	        },true);
		}
		else if (this.params.chart.type == "heatmap"){
			// special handling for heatmap
			// col 0 is xAxis Categories
			//Column Names are yAxis Categories
			// cols 1-N are data
			var ycategories = "[";
			for (i = 1; i < aColumnNames.length; i ++){
				ycategories += "\"" + aColumnNames[i] + "\"";
				if (i < aColumnNames.length - 1)
					ycategories += ", ";
			}
			ycategories += "]";
			//console.log("yAxis.categories="+ycategories);
			//this.chart.yAxis[0].categories = new Array();
			this.chart.yAxis[0].categories=JSON.parse (ycategories);
			//this.chart.yAxis[0].setCategories (JSON.parse (ycategories), false);
			series="{\"data\": [";
			for(i=0;i<rows.length;i++)
				{
				for(j=1;j< aColumnNames.length; j ++)
					{
					series+="["+i+","+(j-1)+","+rows[i][j]+"]";
					
					 if(i<rows.length-1)
						{
						 
						////console.log("iiii"+"i="+i+"j="+j);
						////console.log("j="+j);
						series += ", ";
						
						}
					 else if (j < aColumnNames.length-1)
						{
						// //console.log("jjjj"+"i="+i+"j="+j);
						////console.log("j="+j);
						series += ", ";
						
						}
					}
				}			
			

		series+="]}";
		//console.log("series:["+ series);
		this.chart.addSeries (JSON.parse (series), false);
		
		
		//this.chart.series.dataLabels=JSON.parse(dataLabels);
		}
		else if (this.params.chart.type == "pie" && properties.drilldown){
			var type_json = {};
			var drilldown_series = [];
			var series_1 = {};
			for(var i in rows){
				  if (!!type_json[rows[i][0]]){
					  type_json[rows[i][0]] += rows[i][2];
					  drilldown_series.push({name: rows[i][1] || "Blank", y: rows[i][2]});
				  }
				else{
					type_json[rows[i][0]] = rows[i][2];
					drilldown_series.push({name: rows[i][1] || "Blank", y: rows[i][2]});
				}
			}
			
			for (i = 2; i < aColumnNames.length; i ++){
				series_1.name = aColumnNames[i];
				var data = [];
				for (var key in type_json){
					data.push({"name": key, "y": type_json[key]});
				}
				series = {"name": aColumnNames[i], "data": data}
				
				series.dataLabels= {
		            formatter: function () {
		                return this.y > 5 ? this.point.name : null;
		            },
		            distance: -30
		        }
				this.chart.addSeries (series, false);
			}
			series_1.data = drilldown_series;
			series_1.size = "100%";
			series_1.innerSize = "60%";
			this.chart.addSeries (series_1, false);
		}
		else {
			// cols 1-N are series
			if(properties.stacking=="enabled" && properties.stack!="undefined" && properties.stack!=null)
				{
				var stack=properties.stack.split(",");
				//console.log("Stacking Enabled!!!");
				//console.log("Stack values="+stack);
				for (i = 1; i < aColumnNames.length; i ++){
					series = "{\"name\":\"" + aColumnNames[i] + "\",  \"data\": [";
					//series = "{\"data\": [";
					for (j = 0; j < rows.length; j ++){
						series += "{\"name\":\"" + rows[j][0] + "\", \"y\": " + rows[j][i] + "}";
						if (j < rows.length - 1)
							series += ", ";
					}
					series += "],\"stack\":\"";
					series +=stack[i-1]+"\"}";
					console.log("series:"+ series);
					this.chart.addSeries (JSON.parse (series), false);
				}
				}// this case for generating stack charts with only stacking enabled in application JSON by SG22-10-2018
			// noOfStacks : total number of group stacks to be given in application JSON (group by)
			else if(properties.stacking=="enabled"){
				var noOfStacks=properties.noOfStacks;
				var series='[';
				var x_origin_axis = [];
				for (var k = 0; k < rows.length; k++) {
					var newZone = rows[k][1];
					x_origin_axis.push(newZone)
				}
				function onlyUnique(value, index, self) {
					return self.indexOf(value) === index;
				}

				// usage example:
				
				var unique = x_origin_axis.filter(onlyUnique);
				
				var jsonArrnew = [];
				var dateincludes = [];
				for (var l = 0; l < rows.length; l++) {
					
					let key = rows[l][0];
					if (!dateincludes.includes(key)) {
						var dataList = '';
						var datacount='';
						for (var g = 0; g < rows.length; g++) {
							if (key == rows[g][0]) {
								datacount+=rows[g][2];
								dataList=dataList+	'{\"name\":\"' + rows[g][1] + '\", \"y\": ' + rows[g][2] + '}';
								if(unique.length!=datacount.split(",").length){
									dataList+=',';
									datacount+=',';
								}
							}
							
						}
						dateincludes.push(key);
						series = series+"{\"name\":\"" + key + "\",  \"data\": ["+dataList+"]}";
						if(dateincludes.length!=noOfStacks){
							series+=',';
						}
						/*jsonArrnew.push({
							name : key,
							data : dataList
						})*/
					}
					

				}
				series+=']';
				console.log("series",series);
				this.chart.xAxis[0].setCategories ( unique, true);
				var jsonseries=JSON.parse (series);
				for(var p=0;p<jsonseries.length;p++){
					this.chart.addSeries (jsonseries[p], true);	
				}
				
				console.log("Done:", jsonArrnew)
				
			}
			else if(properties.types!=undefined && properties.types!=null)
				{
				var chart=0;
				for (i = 1; i < aColumnNames.length; i ++){
					var type=(properties.types[chart]==undefined)?((this.params.chart.type==undefined)?"line":this.params.chart.type):properties.types[chart];
						chart++;
					series = "{\"name\":\"" + aColumnNames[i] + "\", \"type\":\""+type+"\", \"data\": [";
					//series = "{\"data\": [";
					for (j = 0; j < rows.length; j ++){
						series += "{\"name\":\"" + rows[j][0] + "\", \"y\": " + rows[j][i] + "}";
						if (j < rows.length - 1)
							series += ", ";
					}
					series += "]}";
					console.log("series:"+ series);
					this.chart.addSeries (JSON.parse (series), false);
				}
				}
			else
			{
				for (i = 1; i < aColumnNames.length; i ++){
					series = "{\"name\":\"" + aColumnNames[i] + "\",  \"data\": [";
					//series = "{\"data\": [";
					for (j = 0; j < rows.length; j ++){
						series += "{\"name\":\"" + rows[j][0] + "\", \"y\": " + rows[j][i] + "}";
						if (j < rows.length - 1)
							series += ", ";
					}
					series += "]}";
					console.log("this.params.chart.type:"+ JSON.stringify(this.params.chart),properties);
					this.chart.addSeries (JSON.parse (series), false);
				}
				//series += "]}";
				//console.log("series:"+ series);
				//this.chart.addSeries (JSON.parse (series), false);
			}
		}
		
		console.log("series outside of if-else:"+ series);
		
	};
	
	this.render =function(containerID){
		//console.log ("DRAWING");
		//console.log (this.chart.xAxis);
		
		console.log(this.chart);
		//console.log("data inside series &&&&&&&&&&&",this.chart.series[0].data);
		this.chart.redraw();
	}
	
}

function displayTooltip (point){
	return point.series.chart.parent.results.hiddenData[point.point.x]; 
}

function displayTooltipForSentiment (point){
	var series_name = point.series.name;
	series_name = series_name.replace(/^\s+/g,'').replace(/\s+$/g,'');
	
	var val;
	if(series_name == "Positive"){
		val = "Count: " + point.series.chart.parent.results.hiddenData[point.point.x][0];
	}
	else if(series_name == "Negative"){
		val = "Count: " + point.series.chart.parent.results.hiddenData[point.point.x][1];
	}
	return val;
}

function linkToUser (label){
	// find the index of the label
	var data = label.chart.parent.results.data;
	var i, index = 0;
	for (i = 0; i < data.length; i ++){
		if (data[i][0] == label.value){
			index = i;
			break;
		}
	}
	// suppose url is in hidden col no. 1 
	var url_column = label.chart.parent.results.hiddenData;
	return "<a href=\"" + url_column[index][0] + "\" target=\"NewWindow\">" + label.value + "</a>";

}